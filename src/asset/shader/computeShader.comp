#version 430 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ----------------------------------------------------------------------------
//
// uniforms
//
// ----------------------------------------------------------------------------

layout(rgba16f, binding = 0) uniform writeonly image2D imgOutput;
//layout(binding = 0, rgba8) uniform writeonly image2D destImg;
layout(binding = 0) uniform sampler2D inputTex;   // using texture()
layout(binding = 1) uniform usampler3D voxelTex;   // using texture()

uniform float t;                 /** Time */
uniform float dt;   
uniform int frame;   
uniform mat4 view;   
uniform vec3 cpos;
uniform vec3 cup;
uniform vec3 cfront;
uniform vec3 cright;
uniform int voxeldomainsidel;
// ----------------------------------------------------------------------------
//
// functions
//
// ----------------------------------------------------------------------------
int checkvoxelint(vec3 cell)
{
    ivec3 c = ivec3(mod(cell,vec3(voxeldomainsidel)));
	//c = ivec3(cell);
	bool v = texelFetch(voxelTex, ivec3(c),0).r == 0;

    //float d = abs(cell.y)-1.;
	return int(texelFetch(voxelTex, ivec3(c),0).r);
}
bool checkvoxel(vec3 cell)
{
    ivec3 c = ivec3(mod(cell,vec3(voxeldomainsidel)));
	//c = ivec3(cell);
	bool v = texelFetch(voxelTex, ivec3(c),0).r == 0;

    //float d = abs(cell.y)-1.;
	return v;
}
float dda(inout vec3 normal,inout int axis,vec3 ro, vec3 rd,int maxi, vec3 cell)
{
    cell = floor(ro)+.5;
   vec3 lp = fract(ro);
   vec3 d = abs(1./rd);  
   vec3 st = sign(rd);
   vec3 l;
   l.x = rd.x <0.? d.x*lp.x: d.x*(1.-lp.x); 
   l.y = rd.y <0.? d.y*lp.y: d.y*(1.-lp.y);
   l.z = rd.z <0.? d.z*lp.z: d.z*(1.-lp.z);   

   axis = -1;
   
   for(int i = 0; i<maxi;i++)
   {
       axis = l.x < l.y
              ? l.x < l.z ? 0 : 2 
              : l.y < l.z ? 1 : 2;
       
        
        cell[axis] += st[axis];
        if(checkvoxel(cell)) break;  
        l[axis] += d[axis];
    }
    
    normal = vec3(0);
    normal[axis] = -st[axis];
    return l[axis];   
}
float mdist(vec3 t)
{
    return abs(t.x) +abs(t.y) + abs(t.z);

}
float hash21(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float hash31(vec3 p3)
{
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return fract((p3.x + p3.y) * p3.z);
}
vec3 shade(vec3 p, vec3 normal, vec3 ro, vec3 rd)
{
 vec3 dl = normalize(vec3(cos(t),sin(t),1.));
  float d = clamp(dot(normal,-dl),0.,1.);
  float mdist = mdist(p-ro);
  float far = step(mdist,16*32-1);
  float s = 100.;
  float f = max(0.,mdist-227.+s)/s;
        f = max(0.,1.-f*f);
        f = exp(-length(p-ro)*.002);
  float r = hash31(floor(p));
  float r1 = hash31(floor(p*5.));
    vec3 fogcol = vec3(1);
  vec3 farcol = pow(vec3(0.302,0.580,1.000),vec3(2.2));
  vec3 rcol = sin(vec3(0,2,4) +r*6.)*.5+.5;
  vec3 rcol1 = sin(vec3(0,2,4) +r1*6.)*.5+.5;
  vec3 vcol = vec3(0.514,1.000,0.141);   
       vcol = mix(vcol,rcol,.2);
       vcol = mix(vcol,rcol1,.1);
       vcol = pow(vcol,vec3(2.2));
       vec3 n2;
       int axis;
       vec3 c;
         float sha = dda(n2,axis,p+normal*.0001,-dl,50, c);
        sha = float(sha>25.);
        sha = sha*.8+.2;
  vec3 col = vcol*d*.7;
       col += vcol*.2;
       col += farcol*.1; 
  float spec = pow(max(dot(reflect(-dl,normal),rd),0.),4.); //spec is acting weird
       col += spec*vec3(1)*.5*(.2+.8*step(.9,r1))*sha;
       col += pow(dot(-rd,normal),5.)*vec3(0.,.1,.1)*.5; //fresnel
       //col *= pow(dot(-rd,normal),5.)*.2+.8; //fresnel
       // col+= spec;
       // col *= sha;
  col = mix(farcol,col,far);
  // col = mix(fogcol,col,f);

return         (pow(dot(normalize(vec3(.5,2.,0.5)),normal)*vec3(1),vec3(1.)));

  return pow(col,vec3(1./2.2));}
vec3 voxelNormal3x3(vec3 p)
{
    vec3 g = vec3(0.0);

    for (int z = -1; z <= 1; z++)
    for (int y = -1; y <= 1; y++)
    for (int x = -1; x <= 1; x++)
    {
        float v = float(checkvoxel(p + (vec3(x,y,z))*1.)); //offset scaler is set to 2 at the moment
        vec3 d = vec3(x,y,z);

        g += v * d;
    }

    return  normalize(g);
}
vec3 voxelNormal(ivec3 p)
{
    const int k = 20;
    float dx = checkvoxelint(p + ivec3(1,0,0)*k) - checkvoxelint(p - ivec3(1,0,0)*k);
    float dy = checkvoxelint(p + ivec3(0,1,0)*k) - checkvoxelint(p - ivec3(0,1,0)*k);
    float dz = checkvoxelint(p + ivec3(0,0,1)*k) - checkvoxelint(p - ivec3(0,0,1)*k);
    return -normalize(vec3(dx, dy, dz));
}
void main() {
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if((texelCoord.x/32 + texelCoord.y/32+frame)%2 == 0) return;
	vec2 res =vec2(gl_NumWorkGroups*gl_WorkGroupSize);
	vec2 uv = (gl_GlobalInvocationID.xy*2.-res)/res.y; 
	float speed = 100;
	// the width of the texture
	//float width = 1000;
	///texelCoord /= gl_NumWorkGroups * gl_WorkGroupSize;


	vec3 ro = vec3(cpos*10.);
//	vec3 rd = normalize(vec3(uv,1.5))*vec3(-1,-1,1) * (mat3(view));
	vec3 rd  = normalize(uv.x*cright + uv.y*cup + cfront);
    vec3 normal = vec3(0);
	int axis =-1;
    vec3 cell;
	float d = dda(normal,axis,ro,rd,16*32, cell);  

	vec3 p = ro + d*rd;
    p -= normal*.005;
    vec3 vnormal = voxelNormal(ivec3(p));
	
    
	float c = mod(floor(p.x)+floor(p.y) + floor(p.z),2.);	
	c = smoothstep(0., .02,c);
    vec3 te = uv.x<0.? normal : -vnormal ;
 //   te *= vec3(-1,-1,1.);
   vec4 col =vec4(shade(p,te, ro, rd),1.);
   //vec4 col = vec4(te ,1);
	//imageStore(imgOutput, ivec2(texelCoord),vec4(col.xyz,1.));// vec4(dot(normalize(vec3(0.5,-1,-.5)),te)) );
    imageStore(imgOutput, ivec2(texelCoord),vec4(te,1.));// vec4(dot(normalize(vec3(0.5,-1,-.5)),te)) );
}